- [请说说你对守护进程，僵尸进程和孤儿进程的理解](https://github.com/suxiongwei/without-me/blob/main/src/main/java/com/sxw/learn/leetcode/md/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.md)
- [请解释一下什么是虚拟内存？分段？分页？](https://github.com/suxiongwei/without-me/blob/main/src/main/java/com/sxw/learn/leetcode/md/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.md)

### 计算机基础&网络
##### TCP和UDP的区别
<details>
<summary>展开</summary>

TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个， 之所以命名为TCP/IP协议，因为TCP、IP协议是两个很重要的协议，就用他两命名了。

TCP/IP协议集包括应用层,传输层，网络层，网络访问层。

- 1、基于连接与无连接； 
- 2、对系统资源的要求（TCP较多，UDP少）； 
- 3、UDP程序结构较简单； 
- 4、流模式与数据报模式 ； 
- 5、TCP保证数据正确性，UDP可能丢包； 
- 6、TCP保证数据顺序，UDP不保证。

https://zhuanlan.zhihu.com/p/24860273
</details>

##### ping命令是基于什么协议
<details>
<summary>展开</summary>
ping命令是用来探测主机到主机之间是否可通信，如果不能ping到某台主机，表明不能和这台主机建立连接。

ping命令是使用 IP 和网络控制信息协议 (ICMP)，**因而没有涉及到任何传输协议(UDP/TCP) 和应用程序**。它发送icmp回送请求消息给目的主机。

ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。
控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。
</details>

##### 数据链路层的主要功能是什么?
<details>
<summary>展开</summary>
1. 将数据组合成数据块，封装成帧
2. 差错控制
3. 流量控制
4. 链路控制
5. MAC寻址
6. 区分数据和控制信息
7. 透明传输
</details>

##### 四次挥手
每个方向都需要一个FIN和一个ACK，因此通常需要四个分节，所以我们称他为四次挥手。

##### TCP四次挥手可以变成三次吗？
<details>
<summary>展开</summary>
可以的

服务端将FIN和ack合并成一条进行发送。为什么会进行合并呢？是因为在关闭的时候，服务端没有数据发送给客户端，然后优化后就会将FIN和ack合并在一起发送给客户端
</details>

##### TCP time_wait
<details>
<summary>展开</summary>
服务器端发送一个FIN时，客户端会处于time_wait状态。当处于time_wait状态时，我们无法创建新的连接，因为端口被占用
</details>

##### time_wait有什么作用？
<details>
<summary>展开</summary>
> 主动断开方在TIME-WAIT状态必须等待2MSL

1. 可靠的终止TCP连接,能确保被动方顺利进入到CLOSED状态。只有这样，双方都能够确保关闭。

若处于time_wait的客户端发送给服务器确认报文段丢失的话，服务器将在此重新发送FIN报文段，那么客户端必须处于一个可接收的状态就是time_wait状态而不是close状态。

2. 保证让迟来的TCP报文段有足够的时间识别并丢弃

linux中一个TCP端口不能被打开两次或两次以上，当客户端处于time_wait状态时我们将无法使用此端口建立新连接。

主动断开方在发送完最后一个ACK报文后，再经过2MSL，才能最终关闭和释放端口，这就意味着，相同端口的新TCP新连接，需要在2MSL的时间之后，才能够正常的建立。
2MSL这段时间内，旧连接所产生的所有数据报文，都已经从网络中消失了，从而，确保了下一个新的连接中不会出现这种旧连接请求报文。
</details>

##### 一定是客户端才有time_wait状态吗？
<details>
<summary>展开</summary>
**不是**，当客户端进行主动关闭时，time_wait存在于客户端
</details>

##### CLOSE_WAIT
<details>
<summary>展开</summary>
为什么这么多CLOSE_WAIT ？

CLOSE_WAIT就是连接被动关闭端的应用没调socket.close

CLOSE_WAIT是被动关闭端在等待应用进程的关闭

https://plantegg.github.io/2021/04/06/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9ACLOSE_WAIT/
</details>

##### 如果已经建立了连接，但是Client端突然出现故障了怎么办？
<details>
<summary>展开</summary>
CP还设有一个保活计时器，Client端如果出现故障，Server端不能一直等下去，这样会浪费系统资源。每收到一次Client客户端的数据帧后，Server端都的保活计时器会复位。
计时器的超时时间通常是设置为2小时，若2小时还没有收到Client端的任何数据帧，Server端就会发送一个探测报文段，以后每隔75秒钟发送一次。
若一连发送10个探测报文仍然没反应，Server端就认为Client端出了故障，接着就关闭连接。
如果觉得保活计时器的两个多小时的间隔太长，可以自行调整TCP连接的保活参数。
</details>

##### select和epoll
<details>
<summary>展开</summary>
>  select/poll/epoll 是用来实现多路复用的，即一个线程利用它们即可 hold 住多个 socket

https://www.zhihu.com/question/22863976/answer/2360953876
</details>

##### 零拷贝
<details>
<summary>展开</summary>
零拷贝不是不拷贝，只是减少拷贝次数

就是之前的拷贝流程是，数据从网卡过来，网卡的数据得到内存里面，cpu才能处理。
可是内存这块儿，分了两个权限不同的区域，高权限的区域叫内核态，低权限的区域叫用户态。
cpu要处理数据就要到内核态，所以网卡的数据要在内存里搬2次到cpu，0拷贝就是，提供一次就搬到内存里面给cpu了。

</details>

##### Java中的线程与操作系统的线程有什么区别？
<details>
<summary>展开</summary>
> Java 中线程的本质，其实就是操作系统中的线程，其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现

首先，日常开发中都是会使用线程池来获取或者创建线程的，而线程在创建时，其实是先创建一个java线程，等到本地存储、程序计数器、缓冲区等都分配好以后，JVM会调用操作系统的方法，创建一个与java线程绑定的原生线程。
线程的调度是由操作系统负责的。</br>
当操作系统为线程分配好时间片以后，就会调用java线程的run方法执行线程。</br>
当线程结束后，会释放java线程和原生线程所占用的资源
</details>

##### TCP具体是通过怎样的方式来保证数据的顺序化传输呢？
<details>
<summary>展开</summary>
> 每个数据包会被分配一个序列号，接收方按顺序接受并确认

具体步骤如下：</br>
（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；</br>
（2）并为每个已发送的数据包启动一个超时定时器；</br>
（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;</br>
（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</br>
（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去</br>
</details>

##### TCP传输数据时的优化策略
<details>
<summary>展开</summary>
TCP 的传输速度，受制于发送窗口与接收窗口，以及网络设备传输能力。

发送缓冲区的大小 约等于 带宽时延积

带宽时延积 BDP = RTT * 带宽

> TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是滑动窗口的由来。
</details>

##### 简述Cookie是什么？
<details>
<summary>展开</summary>
1. Cookie是浏览器访问服务器后，服务器传给浏览器的一段数据。
2. 浏览器需要保存这段数据，不得轻易删除。
3. 此后每次浏览器访问该服务器，都必须带上这段数据。
</details>

##### 请求转发和重定向的区别
<details>
<summary>展开</summary>
**请求转发**：客户浏览器发送http请求，web服务器接受此请求，调用内部的一个方法在容器内部完成请求处理和转发动作，将目标资源发送给客户;
在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。
在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。

**重定向过程**：客户浏览器发送http请求，web服务器接受后发送**302状态码**响应及对应新的location给客户浏览器，
客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址，服务器根据此请求寻找资源并发送给客户。
在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。
</details>
