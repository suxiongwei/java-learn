[TOC]



## 资源限制型题目解题技巧

- hash函数可以把数据按照种类进行分流
- 布隆过滤器用于集合的建立与查询，并可以节省大量空间
- 一致性hash解决数据服务器的负载管理问题
- 利用并查集结构做岛问题的并行计算
- 位图解决某一范围上数字的出现情况，并可以节省大量空间
- 利用分段统计思想，并进一步节省大量空间
- 利用堆、外排序来做多个处理单元的结果合并
## 相关题目
### 找到100亿个URL中重复的URL及搜索词汇的TopK问题
- 原问题：有一个包含100亿个URL的大文件,假设每个URL占用64B,请找出其中所有重复的URL

- 进阶：某搜索公司一天的用户搜索词汇是海量的(百亿数据量),请设计一种求出每天热门Top100词汇的可行办法.

**原问题思路：**

原问题的解法使用解决大数据问题的一种常规方法:把大文件通过哈希函数分配到机器,或者通过哈希函数把大文件拆成小文件,一直进行这种划分,直到结果满足资源限制的要求.

首先,你要向面试官询问在资源上的限制有哪些,包括内存\计算时间等要求.在明确了限制要求之后,可以将每条URL通过哈希函数分配到若干台机器或者拆分成若干小文件,这里的"若干"由具体的资源限制来计算出精确的数量.

例如,将100亿字节的大文件通过哈希函数分配到100台机器上,然后每一台机器分别统计分给自己的URL中是否有重复的URL,同时哈希函数的性质决定了同一条URL不可能分给不同的机器;
或者单机上将大文件通过哈希函数拆成1000个小文件,对每一个小文件再利用哈希表遍历,找出重复的URL;
还可以在分给机器或拆完文件之后进行排序,排序过后再看是否有重复的URL出现.
总之牢记一点,很多大数据问题都离不开分流,要么是用哈希函数把大文件的内容分配给不同的机器,要么是用哈希函数把大文件拆成小文件,然后处理每一个小数量的集合.

**进阶问题思路：**

前置知识:
> 大根堆和小根堆可以容易获取数据结构内最大值、最小值的数据结构，在很多地方上都有应用。
>
> 理解：
> 大根堆/小根堆，是一棵完全二叉树。特点是节点都大于/小于它的孩子节点。
>
> 每次弹出元素的时候，总是从树的最顶端弹出，因此每次都可以获取该二叉树的最大/最小值。
>
> 最开始还是用哈希分流的思路来处理,把包含百亿数据量的词汇文件分流到不同的机器上,具体多少台机器由面试官规定或者由更多的限制来决定.

最开始还是用哈希分流的思路来处理,把包含百亿数据量的词汇文件分流到不同的机器上,具体多少台机器由面试官规定或者由更多的限制来决定。

对每一台机器来说,如果分到的数据量依然很大,比如,内存不够或存在其他问题,可以再用哈希函数把每台机器的分流文件拆成更小的文件处理。

处理每一个小文件的时候,通过哈希表统计每种词汇及词频,哈希表记录建立完成后,再遍历哈希表,遍历哈希表的过程中使用大小为100的小根堆来选出一个小文件Top 100(整体未排序的Top 100)。

每一个小文件都有自己词频的小根堆(最小堆)(整体未排序的Top 100),将小根堆里的词按照词频排序,就得到了每个小文件的排序后Top 100。

然后把各个小文件排序后的Top 100进行外排序或者继续利用小根堆,就可以选出每台机器上的Top100。

不同机器之间的Top100再进行外排序或者继续利用小根堆,最终求出整个百亿数据量中的Top100。

对于Top K的问题,除用哈希函数分流和用哈希表做词频统计之外,还经常用堆结构和外排序的手段进行处理.

> 构建小根堆的细节
>
> 满了100个元素之后，如果当前元素比堆里的全部元素大，则加入堆，并移除堆顶元素
>
> 这样一直扫描完全部文件就构建好了这个文件的top 100


如果内存要求不能构建太大的堆，还可以构建大根堆，比如求的是top 10，大根堆只能存3个元素，这样的话大根堆的作用就是可以排除掉最小的元素，
下次扫描文件时就可以过滤掉已有的小元素，直到全部排除完，就找到了top K

原理:大根堆有门槛，可以判断出要不要走这个门槛


### 40亿个非负整数中找到没出现的数

- 原问题：32位无符号整数的范围是0-4294967295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。最多一可使用1GB的内存空间，怎么找到左右没出现过的数？
- 进阶：内存限制为10MB，但是只用找到一个没有出现过的数即可。

**1、原问题思路**

如果用哈希表来保存出现过的数，那么如果40亿个数都不同，则哈希表记录为40亿条，每条记录占4B，共占用内存40亿*4B=160亿字节=16GB，内存不够用。可以用BitMap来表示出现过的数。具体做法是：

    1、申请一个长度为4294967295的bit类型的数组bitArr，bitArr上的没个位置有0，1两种状态，共占用内存500M。
    2、遍历这40亿个数，如遇到7000，就把bitArr[7000]置为1。
    3、遍历完成以后，再遍历bitArr，如果bitArr[i] = 0，则i没出现过，否则，i出现过，这样就可以把所有的未出现的数找出来。
**2、进阶思路**

    现在只有10M的内存空间，但只要求找到其中一个没出现过的数即可。首先，0-4294967295这个范围可以平均分成N个区间，每个区间是M个数，例如：第0区间(0， M-1)，第一区间(M, 2M-1)....第N-1区间(M*(n-1)-1，4294967295)。因为一共只有40亿个数，所以，如果统计落在每一个区间上的数有多少，肯定有一个区间的计数少于M。利用这一点可以找到其中一个没出现过的数。
具体做法是：
设N为64，则M为67108864。

1、第一次遍历时，先申请长度为64的数组countArr，用来统计每一个区间数出现的次数，遍历40亿个数，当前数为i， countArr[i/67108864]++。
2、第二次遍历，遍历countArr数组，找出countArr值小于67108864的区间，如countArr[51] < 67108864，则缺少的数在第51区间上。**（至此锁定了未出现的其中一个数的区间）**
3、第三次遍历，遍历40亿个数。
3.1、申请长度为67108864的bitmap，占用大约8MB空间，即为bitmap[]。
3.2、遍历40亿个数，此时只关注落在区间51上的数
3.3、如果步骤2的num落在51区间，将bitmap[num]置1.
3.4、遍历完40亿个数后，再遍历bitmap，如果其中的第i位没有置1，则67108864*51+i这个数就是没出过的数。
**总结：**
1、根据10MB的内存限制，确定统计区间的大小，就是bitArr的大小.
2、利用区间计数的方式，找到计数不足的区间，这个区间上肯定有没出现过的数。
3、对这个区间上的数做bitmap映射，再遍历bitmap，找到未出现的数。

