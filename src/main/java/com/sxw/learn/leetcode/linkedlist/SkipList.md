## 跳表
**目的:** 提高查询效率</br>
**实现思路:** 利用多级索引，基于单链表实现了二分查找，空间换时间</br>
**实现方式:** 链表加多级索引的结构</br>
**时间复杂度:** O(logn)</br>
> 跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)</br>

**空间复杂度:** O(n)</br>
> 实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数。</br>
> 但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，</br>
> 所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了

**如何维护平衡性:** 通过随机函数</br>
> 作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，</br>
> 以及查找、插入、删除操作性能下降。如果你了解红黑树、AVL 树这样平衡二叉树，你就知道它们是通过左右旋的方式保持左右子树的大小平衡，</br>
> 而跳表是通过随机函数来维护前面提到的“平衡性”。</br>

## 为什么 Redis 要用跳表来实现有序集合，而不是红黑树？
Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。</br>
如果你去查看 Redis 的开发手册，就会发现，Redis 中的有序集合支持的核心操作主要有下面这几个：</br>
- 插入一个数据
- 删除一个数据
- 查找一个数据；
- 按照区间查找数据（比如查找值在[100, 356]之间的数据）；
- 迭代输出有序序列。

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。</br>
**但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高**对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。</br>

当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，**跳表更容易代码实现**。</br>
虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。</br>
还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</br>
不过，**跳表也不能完全替代红黑树**。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。</br>
我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。
