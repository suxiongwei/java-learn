## 孤儿进程与僵尸进程
在linux当中，**子进程是由父进程创建的**，子进程再创建新的进程。子进程的结束和父进程的运行是一个**异步**的过程，即父进程永远无法预测子进程到底什么时候结束。

unix系统**提供了一种机制可以让父进程获得子进程结束时的状态信息**，也就是说在每个进程退出的时候，内核释放该进程所有的资源，
包括打开的文件，占用的内存，但是仍然为其保留一定的信息,如进程号，退出状态，运行时间等。
那么，当一个子进程完成它的工作终止之后，它的**父进程就要调用wait()或者waitpid()系统调用来取得子进程的终止状态**。

### 孤儿进程
一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。
孤儿进程将被init进程（进程号为1）所收养，并由init进程完成对它们状态收集工作。

### 僵尸进程
一个进程使用 fork创建子进程，如果子进程退出，而父进程没有调用wait或waitpid函数获取子进程的状态信息，那么子进程的进程描述符仍然会保存在系统中。
这种进程称为僵尸进程。

### 危害：
**僵尸进程**：在子进程退出时，如果父进程不调用wait或waitpid函数的话，那么系统保留的子进程的信息就不会被释放。</br>
其子进程号会一直被占用，但是系统所能使用的进程号是有限的，如果产生大量的僵尸进程，最终可能导致系统没有可用的进程号，从而不能产生新的进程。

例如有个进程，它定期的产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，
因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问，</br>
这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z（defunct）的进程。</br>
严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。

因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。</br>
枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源。</br>
这样，这些已经僵死的孤儿进程 就能瞑目而去了。

**孤儿进程**：孤儿进程因为在其父进程退出时被init进程所收养，所以init进程会wait()孤儿进程，所有孤儿进程并没有什么危害。
