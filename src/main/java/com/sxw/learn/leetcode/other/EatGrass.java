package com.sxw.learn.leetcode.other;

/**
 * [题目]: [牛羊吃草问题]
 * [题目描述]: 给定一个正整数N，表示N份青草放在一个仓库里面，有一只牛和一只羊，牛先吃，他俩轮流进行吃草，不管是牛还是羊，每一轮吃的草量，必须是4的N次方，即：1，4，16，64...
 * 谁先把草吃完，谁获胜；
 * 假设：牛和羊都是绝顶聪明，都想赢，都会做出合理的决定
 *
 * [审题]:
 * 示例：
 * n=0
 * 牛先吃，直接面对无草可吃，牛输，羊赢
 * n=1
 * 牛先吃，只能吃1份，n=0，则牛赢
 * n=2,
 * 牛先吃，也只能吃1份，然后羊吃1份，羊先吃完的，羊赢了
 * n=3
 * 牛1份，羊1份，牛1份，n=0，牛赢
 * n=4
 * 牛4份，牛赢了，因为它可以吃4的0 1 2 等次方份
 * ……
 *
 * [暴力解的方式]:
 * 咱们看到了结果只与n有关
 * 先手为牛，后手暂时为羊
 *
 * 不妨设f(n）是先手来吃，吃完看看返回谁赢？
 * 0   1   2   3   4
 * 后  先  后  先  先
 * （1）如果先手进来发现n=0，则不好意思，后手赢了，后手让我首先面临n=0的无草可吃的地步，我先手输
 * （2）如果n还有，我先手从k=1份，4份，16份64份……4的n次方尝试吃，这个数量k不能超过n，我先手吃下去k份之后，还剩n-k份草
 * （3）下次我只能做为后手去吃剩下的n-k份草了【因为下次就是我的对手即后手，做先手去吃了】，如果发现我再以后手的身份吃n-k份，返回来说后手赢了，那恰好就是我先手赢。
 * （4）如果（3）中我做后手吃这剩下的n-k份，一直返回先手赢，那你要明白，现在的这个赢家先手可是我的对手（后手）啊，我就不能尝试看这种方案吃k份了，还得换更大的k尝试。
 * （5）如果直到k超过n都不行，那我完蛋了，我做先手吃怎么都没法取胜，后手自动赢了。
 * 非常重要的就是理解这（3），我吃完k份，剩下n-k是我今后以后手的身份去吃的，说了半天其实就是我先手一个人吃完的，但是我模拟了先后手交替吃的流程。
 * <span>博弈问题的核心：就是理解身份的转换</span>
 *
 * [观察表法的方式]:
 * 通过以上暴力递归的方式，观察答案的结果：
 * N 从0～9
 * 后手
 * 先手
 * 后手
 * 先手
 * 先手
 * 后手
 * 先手
 * 后手
 * 先手
 * 先手
 * 可以得出答案的规律为：后、先、后、先、先 循环往复
 * 因此可以利用规律直接出答案
 */
public class EatGrass {
    public static String eatGrass(int N){
        if (N < 5) return (N == 0 || N == 2) ? "后手" : "先手";// 小于5份直接出答案
        int base = 1;// 处理N >= 5时，先手决定吃的数量
        while (base <= N){
            if (eatGrass(N - base).equals("后手")) return "先手";// 母过程的"先手"在子过程就是"后手"
            if (base * 4 > N) break;// 越界条件，不能再乘以4去尝试了，break
            base *= 4;
        }
        return "后手";
    }

    public static String eatGrass1(int N){
        return (N % 5 == 0 || N % 5 == 2) ? "后手" : "先手";
    }

    public static void main(String[] args) {
        for (int i = 0; i < 30; i++) {
            System.out.println(eatGrass(i));
        }
    }
}
