## 排序算法的稳定性及其汇总

|          | 时间复杂度  | 空间复杂度 | 稳定性 |
| -------- | ----------- | ---------- | ------ |
| 选择排序 | O(N^2)      | O(1)       | 否     |
| 冒泡排序 | O(N^2)      | O(1)       | 是     |
| 插入排序 | O(N^2)      | O(1)       | 是     |
| 归并排序 | O(N * logN) | O(N)       | 是     |
| 快速排序 | O(N * logN) | O(logN)    | 否     |
| 堆排序   | O(N * logN) | O(1)       | 否     |
> 目前没有找到时间复杂度O(N * logN)，额外空间复杂度O(1)的，又稳定的排序
### 稳定排序：
- 冒泡排序
- 插入排序
- 归并排序
- 一切桶排序思想下的排序

### 非稳定性的排序
- 选择排序
- 快速排序
- 堆排序

### 基于比较的排序
* 基于比较的排序，定义好排序算法，过程是可以复用的，比如冒泡排序、插入排序...
* 不基于比较的排序，对数据的数据状况要求较高
### 常见的坑：
> 有一道题目，将数组的奇数放在左边，偶数放在右边，还要求原始的相对次序不变

题目分析：划分奇数和偶数本质上和快速排序的partition流程是一致的，快排是划分小于等于界和大于界限，这里是划分奇偶。因此快速排序做不到稳定，这道题在空间复杂度和时间复杂度要求和快速排序一致的情况下还要求稳定是做不到的。

### 工程上对排序的改进
1、充分利用O(N * logN) 和 O(N^2)  排序各自的优势

比如：在大样本情况下选择快速排序，小样本情况下选择插入排序，因此各个语言封装的排序算法是综合排序，会考虑到各种各样的情况，选择不同的排序策略 

2、稳定性的考虑

比如：基础数字可以不考虑稳定，但是DTO类型的Java Bean则可能需要稳定性