## 二叉查找树(Binary Search Tree/ BST)
### 时间复杂度
**查找：**
- 最好的情况是 **O(logn)**，存在于完全二叉排序树情况下，其访问性能近似于折半查找；
- 最差时候会是 **O(n)**，比如插入的元素是有序的，生成的二叉排序树就是一个链表

**插入删除：**
- 时间复杂度与查找差不多

## 平衡二叉查找树(Balanced Binary Search Tree/ AVL)
### 为什么会有AVL？
BST在最差情况下竟然和顺序查找效率相当，这是无法仍受的。<br/>
事实也证明，当存储数据足够大的时候，树的结构对某些关键字的查找效率影响很大。<br/>
当然，造成这种情况的主要原因就是BST不够平衡(左右子树高度差太大)。<br/>
既然如此，那么我们就需要通过一定的算法，将不平衡树改变成平衡树。<br/>
因此，AVL树就诞生了。

### 时间复杂度
**查找：**<br/>
最好，最坏情况都是 **O(logN)** 数量级的。<br/>

**插入：**<br/>
总体上插入操作的代价在 **O(logN)** 级别上(插入结点需要首先查找插入的位置)。<br/>

**删除：**<br/>
时间复杂度为 **O(logN)+O(logN)=O(2logN)** <br/>

## 红黑树(Red-Black Tree/ RBT)
### 为什么会有红黑树？
- 因为BST在最坏的情况下时间复杂度为O(N)
- AVL的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价
因此产生了红黑树

### 时间复杂度
RBT本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。<br/>
这些规则使红黑树保证了一种**平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)**。
### 红黑树的性质
- 每个节点要么是红色，要么是黑色；
- 根节点永远是黑色的；
- 所有的叶节点都是是黑色的；
- 每个红色节点的两个子节点一定都是黑色；
- 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；

> 性质 3 中指定红黑树的每个叶子节点都是空节点，而且叶子节点都是黑色。但 Java 实现的红黑树将使用 null 来代表空节点，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的。<br/>
> 性质 4 的意思是：从每个根到节点的路径上不会有两个连续的红色节点，但黑色节点是可以连续的。<br/>
>   因此若给定黑色节点的个数 N，最短路径的情况是连续的 N 个黑色，树的高度为 N - 1;最长路径的情况为节点红黑相间，树的高度为 2(N - 1) 。<br/>
> 性质 5 是成为红黑树最主要的条件，后序的插入、删除操作都是为了遵守这个规定。


## B-树/B+树(B-Tree)
对于在内存中的查找结构而言，红黑树的效率已经非常好了(实际上很多实际应用还对RBT进行了优化)。<br/>
但是如果是数据量非常大的查找呢？将这些数据全部放入内存组织成RBT结构显然是不实际的。<br/>
实际上，像OS中的文件目录存储，数据库中的文件索引结构的存储…. 都不可能在内存中建立查找结构。必须在磁盘中建立好这个结构。那么在这个背景下，RBT还是一种好的选择吗？<br/>
在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。<br/>
大家都知道，频繁的磁盘IO操作，效率是很低下的(机械运动比电子运动要慢不知道多少)。<br/>
显而易见，所有的二叉树的查找结构在磁盘中都是低效的。因此，B树很好的解决了这一个问题。<br/>

### 时间复杂度
B-Tree效率总结：<br/>

由于考虑磁盘储存结构，B树的查找、删除、插入的代价都远远要小于任何二叉结构树(读写磁盘次数的降低)。

## 动态查找树结构的对比：
### AVL PK RBT
AVL 和RBT 都是二叉查找树的优化。其性能要远远好于二叉查找树。他们之间都有自己的优势，其应用上也有不同。<br/>

**结构对比：** <br/>

AVL的结构高度平衡，RBT的结构基本平衡。平衡度AVL > RBT.<br/>

**查找对比：** <br/>

AVL查找时间复杂度最好，最坏情况都是O(logN)。RBT 查找时间复杂度最好为O(logN)，最坏情况下比AVL略差。<br/>

**插入删除对比：**<br/>

1. AVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，**RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL**。
2. 如果需要平衡处理时，RBT比AVL多一种变色操作，而且变色的时间复杂度在O(logN)数量级上。但是由于操作简单，所以在实践中这种变色仍然是非常快速的。
3. 当插入一个结点都引起了树的不平衡，AVL和RBT都最多需要2次旋转操作。但删除一个结点引起不平衡后，AVL最多需要logN 次旋转操作，而RBT最多只需要3次。
   **因此两者插入一个结点的代价差不多，但删除一个结点的代价RBT要低一些**。
4. AVL和RBT的插入删除代价主要还是消耗在查找待操作的结点上。因此时间复杂度基本上都是与O(logN) 成正比的。
_总体评价：大量数据实践证明，RBT的总体统计性能要好于平衡二叉树。_

### B-Tree PK B+Tree
B+树是B-树的一种变体，在磁盘查找结构中，B+树更适合文件系统的磁盘存储结构。<br/>

**B+树相比B-树的特点：**<br/>
1. 数据只出现在叶子结点，B-树每个结点都包含了数据；
2. 叶子结点之间用指针连接；
3. B+树的高度一般是3；

**结构对比：**<br/>

B-树是平衡多路查找树，所有结点中都包含了待查关键字的有效信息(比如文件磁盘指针)。每个结点若有n个关键字，则有n+1个指向其他结点的指针。

**查找对比：**<br/>

1. 在相同数量的待查数据下，B+树查找过程中需要调用的磁盘IO操作要少于普通B-树。由于B+树所在的磁盘存储背景下，因此B+树的查找性能要好于B-树。
2. B+树的查找效率更加稳定，因为所有叶子结点都处于同一层中，而且查找所有关键字都必须走完从根结点到叶子结点的全部历程。
3. 因此同一颗B+树中，任何关键字的查找比较次数都是一样的。而B树就不一定了，可能查找到某一个非终结点就结束了。

**插入删除对比：** <br/>

B+树与B-树在插入删除操作中的效率是差不多的。<br/>

_总体评价：在应用背景下，特别是文件结构存储中。B+树的应用要更多，其效率也要比B-树好。_
  