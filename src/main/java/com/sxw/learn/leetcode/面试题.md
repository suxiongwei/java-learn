## 一些面试题
### Java
#### 为什么任何一个对象都可以成为一个锁？
每个对象都有一个监视器
#### 非公平锁的优点
减少线程的切换，更能充分的利用CPU
#### [两个线程交替打印0-100的奇偶数](https://github.com/suxiongwei/without-me/blob/main/src/main/java/com/sxw/learn/thread/TurningRunner.java)

### MySQL
#### B-树和B+树的区别
https://www.jianshu.com/p/ace3cd6526c4<br/>
1. B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。
2. B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。
3. B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确
#### MySQL意向锁的作用是什么？
因为 mysql 存在行锁，而行锁与表锁存在互斥的关系，当执行一条 sql 语句出现行锁时，会修改表头的一个标志位，也就是所谓的意向锁。
此时，如果需要锁表时，会去判断标志位，从而迅速知道能否锁表。
#### 意向锁和哪些锁有互斥关系？
https://juejin.cn/post/6844903666332368909 <br/>
意向锁和自家兄弟互相兼容，但是它会与普通的排他/共享锁互斥(表锁)<br/>
*意向锁不会与行级的共享 / 排他锁互斥！！！*
#### 什么是间隙锁(Gap Locks)？
间隙锁，它封锁索引记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。<br/>
在 InnoDB，RR 条件下：<br/>
```sql
select * from lock_example where id between 8 and 15 for update;
```
这个SQL语句会封锁区间(8,15)，以阻止其他事务插入id位于该区间的记录。<br/>
间隙锁的主要目的，就是为了防止其他事务在间隔中插入数据，以导致“不可重复读”。<br/>
如果把事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效。
#### 什么是MVCC？
https://zhuanlan.zhihu.com/p/52977862<br/>
核心：
- 事务版本号
- 表的隐藏列
- undo log
- read view

MVCC是在并发访问数据库时，通过对数据做多版本管理，避免因为写数据时要加写锁而阻塞读取数据的请求，造成写数据时无法读取数据的问题。<br/>
通俗的讲就是MVCC通过保存数据的历史版本(undo log)，根据比较**数据的版本号**来决定数据的是否显示(MVCC快照读：根据版本号获取快照数据版本)，
在不需要加读锁的情况就能达到事务的隔离效果，最终可以在读取数据的时候可以同时进行修改，修改数据时候可以同时读取，极大的提升了事务的并发性能。

#### MVCC是否有解决幻读问题？
快照读的情况下可以避免幻读问题，在当前读的情况下则需要使用间隙锁来解决幻读问题的


### 分布式

### 计算机基础&网络
#### ping命令是基于什么协议
ping命令是基于ICMP协议，是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</br>
控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

#### 数据链路层的主要功能是什么?
1. 将数据组合成数据块，封装成帧
2. 差错控制
3. 流量控制
4. 链路控制
5. MAC寻址
6. 区分数据和控制信息
7. 透明传输

#### Java中的线程与操作系统的线程有什么区别？
> Java 中线程的本质，其实就是操作系统中的线程，其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现

首先，日常开发中都是会使用线程池来获取或者创建线程的，而线程在创建时，其实是先创建一个java线程，等到本地存储、程序计数器、缓冲区等都分配好以后，JVM会调用操作系统的方法，创建一个与java线程绑定的原生线程。
线程的调度是由操作系统负责的。</br>
当操作系统为线程分配好时间片以后，就会调用java线程的run方法执行线程。</br>
当线程结束后，会释放java线程和原生线程所占用的资源

#### TCP具体是通过怎样的方式来保证数据的顺序化传输呢？
> 每个数据包会被分配一个序列号，接收方按顺序接受并确认

具体步骤如下：</br>
（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；</br>
（2）并为每个已发送的数据包启动一个超时定时器；</br>
（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;</br>
（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</br>
（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去</br>

#### TCP传输数据时的优化策略
TCP 的传输速度，受制于发送窗口与接收窗口，以及网络设备传输能力。

发送缓冲区的大小 约等于 带宽时延积

带宽时延积 BDP = RTT * 带宽



> TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是滑动窗口的由来。

#### 简述Cookie是什么？
1. Cookie是浏览器访问服务器后，服务器传给浏览器的一段数据。
2. 浏览器需要保存这段数据，不得轻易删除。
3. 此后每次浏览器访问该服务器，都必须带上这段数据。

#### 用户空间与内核空间
操心系统的核心是**内核**，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。

为了保证用户进程不能直接操作内核，**保证内核的安全**，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。

针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。
每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。

#### 内核态与用户态：
1. 当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。 
2. 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。

#### 进程切换
发生进程调度时，进行进程切换（上下文切换）
> 所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。

#### 虚拟内存
虚拟内存是操作系统为每个进程提供的一种**抽象**，每个进程都有属于自己的、**私有的、地址连续的虚拟内存**，
当然我们知道最终进程的数据及代码必然要放到物理内存上，那么必须有某种机制能记住虚拟地址空间中的某个数据被放到了哪个物理内存地址上，
这就是所谓的地址空间映射。

#### 进程切换和线程切换的区别
最主要的一个区别在于进程切换涉及**虚拟地址空间的切换而线程不会**。

因为每个进程都有自己的虚拟地址空间，而线**程是共享所在进程的虚拟地址空间**的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。



### Java面试被问到项目中的难点如何回答？
数据分析API性能优化</br>

_讲述优化前存在的问题_</br>

架构的升级：
> 存储介质，调研选型，mysql -> ck </br>
> Java 程序的优化，接口鉴权 + 限流 + 熔断 + 降级 + 缓存 + 异步

限流：Hystrix、Sentinel